{"version":3,"sources":["webpack:///webpack/bootstrap 31ce7ffc070d4f2ef5b0","webpack:///./src/inverted-index.js","webpack:///./src/utils.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,QAAQ;AACtB,eAAc,SAAS;AACvB,eAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAoD,cAAc,GAAG,aAAa;AAClF;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;;;;;;;AAQA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB;AACA;AACA;AACA;;;;AAIA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB,eAAc,WAAW;AACzB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,WAAW,EAAE,KAAK,EAAE,WAAW;AACxE;AACA;AACA;AACA,iCAAgC,mBAAmB,GAAG,YAAY,UAAU,MAAM;AAClF,iCAAgC,gCAAgC,GAAG,YAAY;AAC/E;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,UAAU;AACxB,eAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,SAAS;AACzB,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,iCAAgC,UAAU;AAC1C;AACA;AACA,iFAAgF,UAAU,IAAI,SAAS;AACvG,+FAA8F,SAAS;AACvG,+FAA8F,SAAS;AACvG,gCAA+B,UAAU;AACzC,wFAAuF,UAAU;AACjG;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,SAAS;AACzB,iBAAgB,SAAS;AACzB,iBAAgB,SAAS;AACzB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,UAAU;AAC7C,MAAK;AACL;AACA;AACA;AACA,sCAAqC,MAAM;AAC3C,iCAAgC,KAAK;AACrC;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;AC3OA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,kBAAkB;AAC9B;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iBAAgB,SAAS;AACzB,iBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA","file":"31ce7ffc070d4f2ef5b0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 31ce7ffc070d4f2ef5b0","let utils = require('./utils.js');\nlet  utilsInstance = new utils();\n/**\n * A class for Creating and searching an inverted index\n */\nclass Index {\n\n  /**\n   * [constructor Creates Object variables to hold\n   * 1. [jsonDatabase] Uploaded files\n   * 2. [indexFile] the indexed filenames and their contents\n   * 3. [searchResult] the search results\n   * @return {[type]} [description]\n   */\n  constructor() {\n    this.jsonDatabase = {};\n    this.indexFile = {};\n    this.searchResult = {};\n  }\n\n  /**\n   * [saveUploads creates a key and value object item that stores the uploaded file(s)]\n   * @param  {[string} fileName [filename]\n   * @param  {[object]} jsonFile [content of uploaded json file]\n   * @return {[boolean]}          [returns true on succesful addition of object to datatbase]\n   */\n  saveUploads(fileName, jsonFile) {\n    if (!utilsInstance.isValid(fileName, jsonFile)) {\n      return false;\n    }\n    if (typeof jsonFile === 'string') {\n      jsonFile = JSON.parse(jsonFile);\n    }\n\n    this.jsonDatabase[fileName] = [];\n    Object.keys(jsonFile).forEach((keys) => {\n      this.jsonDatabase[fileName].push(jsonFile[keys]);\n    });\n    // for (const docObject in jsonFile) {\n\n    // }\n    return true;\n  }\n    /**\n     * [getjsonDatabase function to return the saved uploads]\n     * @return {[object]} [the saved uploads]\n     */\n  getJsonDatabase() {\n    return this.jsonDatabase;\n  }\n\n  /**\n   * [createIndex Creates an index of the words in the received json file]\n   * @param  {string}   fileName [the key(filename) of the json value to index]\n   * @param  {Function} cb  [call back to return the indexed file object/an html format index table]\n   * @return {[array]} [an arrray of the indexed file result and the html Div of the index]\n   */\n  createIndex(fileName, cb) {\n    const indexFile = this.indexFile;\n    const jsonDoc = this.jsonDatabase[fileName];\n    let mergedContent = '';\n    let wordArray = [];\n    if (indexFile[fileName]) {\n      return false;\n    }\n    indexFile[fileName] = {};\n\n    jsonDoc.forEach((element, index) => {\n      mergedContent = utilsInstance.cleanString((`${element.title} ${element.text}`));\n      wordArray = new Set(mergedContent.split(' '));\n      wordArray.forEach((word) => {\n        indexFile[fileName][word] = indexFile[fileName][word] || [];\n        indexFile[fileName][word].push(index);\n      });\n    });\n    this.indexFile = indexFile;\n    return cb(fileName, indexFile, jsonDoc);\n  }\n\n  \n  \n\n\n\n\n  /**\n   * [getIndex Gets the index object of the indexed json file]\n   * @param  {[string]} fileName [the filename(key) of the index needed]\n   * @return {[object]}          [index of the object]\n   */\n  getIndex(fileName) {\n    return this.indexFile[fileName] || this.indexFile;\n  }\n\n\n\n  /**\n   * [searchIndex It searches the already indexed files for particular words]\n   * @param  {[string]}    fileNames     [description]\n   * @param  {Function}  cb            [description]\n   * @param  {...[Array]} searchContent [the words to search for]\n   * @return {[Array]}                  [an array of two elements, an\n   * object with the search term as key and their locations in the\n   * array of the originally uploaded file, an html view of the result]\n   */\n  searchIndex(fileNames, cb, ...searchContent) {\n    const searchResult = {};\n    let searchTerms = searchContent.join(' ');\n    if (fileNames.length < 1) {\n      fileNames = this.getFilenames();\n    }\n    searchTerms = utilsInstance.cleanString(searchTerms, /[^a-z0-9\\s,]+/gi);\n    searchTerms = searchTerms.split(/[,\\s]/);\n    searchTerms.forEach((searchTerm) => {\n      searchResult[searchTerm] = {};\n      fileNames.forEach((fileName) => {\n        if (this.indexFile[fileName][searchTerm]) {\n          searchResult[searchTerm][fileName] = this.indexFile[fileName][searchTerm];\n        }\n      });\n    });\n    this.searchResult = searchResult;\n    return cb(searchResult, this.jsonDatabase);\n  }\n\n  /**\n   * [createResultHtml Creates an html view based the result of the index search]\n   * @param  {[object]} resultObject [the result of the index search]\n   * @param  {[object]} jsonDatabase [the json database containing the original Uploaded object]\n   * @return {[ogject]}              [returns the search result and the Html view]\n   */\n  createResultHtml(resultObject, jsonDatabase) {\n    this.resultView = '';\n    const termTag = ['<h3>', '</h3>'];\n    const fileTag = ['<p>', '</p>'];\n    const resultContainer = [\"<div class='panel panel-default'>\", '</div>'];\n    const titleTag = [\"<div class='panel-heading result-header'><h3 class='panel-title'> \", '</h3> </div>'];\n    const textTag = [\"<div class='panel-body'> \", '</div>'];\n\n    Object.keys(resultObject).forEach((term) => {\n      this.resultView += `Search Term: ${termTag[0]}${term}${termTag[1]}`;\n      Object.keys(resultObject[term]).forEach((file) => {\n        this.resultView += fileTag[0] + file + fileTag[1];\n        resultObject[term][file].forEach((element, index) => {\n          this.resultView += `${resultContainer[0]} ${titleTag[0]} Index: ${index} `;\n          this.resultView += `${jsonDatabase[file][index].title} ${titleTag[1]}`;\n          this.resultView += textTag[0] + jsonDatabase[file][index].text + textTag[1];\n          this.resultView += resultContainer[1] + titleTag[1];\n        });\n      });\n    });\n    return [resultObject, this.resultView];\n  }\n\n  /**\n   * [getFilenames returns the filenames of all files present in the object]\n   * @return {[array]} [an array of filenames]\n   */\n  getFilenames() {\n    return Object.keys(this.jsonDatabase);\n  }\n\n  /**\n   * [deleteIndex Deletes an index file from the index object]\n   * @param  {[string]} fileName [the filename(key) of the data to delete]\n   * @param  {[boolean]} option   [determines if to delete the index only or also the json file]\n   * @return {[boolean]}  [true to delete indexFile and jsonDatabase/false to delete only the index]\n   */\n  deleteIndex(fileName, option) {\n    delete this.indexFile[fileName];\n    if (option === true) {\n      delete this.jsonDatabase[fileName];\n      return true;\n    }\n    return false;\n  }\n\n    /**\n     * [createIndexHeader Creates the HTML header of the index file based on the uploaded file]\n     * @param  {[string]} FileName [the name of the file(key) to create an index header for]\n     * @return {[string]}          [and HTML Panel header with buttons to create and delete index]\n     */\n  createIndexHeader(FileName) {\n    this.indexHeadView = '';\n    const cFileName = FileName.replace(/[^a-z0-9]+/gi, '');\n    const htmlTop = `<div id=\"${cFileName}-panel\" class=\"panel panel-default \">\n                            <div class=\"panel-heading index-header\">\n                                <h4 class=\"panel-title\">\n                    <a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#${cFileName}\">${FileName}</a></h4>\n                    <span class=\"input-group-addon create-button\" onclick=\"callCreateIndex('${FileName}')\" id=\"create-index\">Create Index</span>\n                    <span class=\"input-group-addon delete-button\" onclick=\"callDeleteIndex('${FileName}')\" id=\"delete-index\">Delete Index</span></div>\n                    <div id=\"${cFileName}\" class=\"panel-collapse collapse in index-body\">\n                    <div class=\"panel-body\"><div class=\"table-responsive\"><table id=\"${cFileName}-table\" class=\"table\"></table></div></div></div></div>`;\n    this.indexHeadView += htmlTop;\n    return this.indexHeadView;\n  }\n\n    /**\n     * [createIndexHtml Creates an html file based on the index of the provided filepath]\n     * @param  {[string]} filePath  [the filename of the index]\n     * @param  {[object]} indexFile [the store of all created index objects]\n     * @param  {[object]} jsonDoc   [the object of the uploaded json file for the file requested]\n     * @return {[array]} returns the index and the html panel representation of the index]\n     */\n  createIndexHtml(filePath, indexFile, jsonDoc) {\n    this.indexView = '';\n    const indexPerPath = indexFile[filePath];\n    this.indexView += '<thead> <th>#</th>';\n    this.indexView += '<th>word</th>';\n    jsonDoc.forEach((element, index) => {\n      this.indexView += `<th>Doc ${index + 1} </th>`;\n    });\n    let count = 1;\n    this.indexView += '<tbody>';\n    Object.keys(indexPerPath).forEach((word) => {\n      this.indexView += `<tr> <td> ${count}</td>`;\n      this.indexView += `<td> ${word} </td>`;\n      jsonDoc.forEach((element, index) => {\n        if (indexPerPath[word].indexOf(index) > -1) {\n          this.indexView += '<td>✔</td>';\n        } else {\n          this.indexView += '<td class=\"neg-tick\">✘</td>';\n        }\n      });\n      this.indexView += '</tr>';\n      count = +1;\n    });\n\n    this.indexView += '</tbody>';\n    return [indexPerPath, this.indexView];\n  }\n}\nmodule.exports = new Index();\n\n\nvar i = new Index();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/inverted-index.js\n// module id = 0\n// module chunks = 0","/**\n * [parseJSON converts sting to a Json object]\n * @param  {string} jsonFile\n * @return {object || boolean}  [the parsed file or false on error]\n */\n  class util{\n\n  parseJSON(jsonFile) {\n    try {\n      return JSON.parse(jsonFile);\n    } catch (err) {\n      return true;\n    }\n  }\n\n  /**\n     * [isValid Check if a file is a valid json object based, calls method to check structure]\n     * @param  {string}  fileName [the filename to verfity if is the object in the database]\n     * @param  {object}  jsonFile [the json object to be tested]\n     * @return {Boolean}          [returns true if valid else false]\n     */\n  isValid(fileName, jsonFile) {\n    if (typeof jsonFile === 'string') {\n      jsonFile = JSON.parse(jsonFile);\n    }\n\n    if (jsonFile && jsonFile.length > 0) {\n      const isValidFileStructure = this.checkFileStructure(jsonFile);\n      if (isValidFileStructure) {\n        if (!this.jsonDatabase[fileName]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n\n    /**\n     * [checkFileStructure Checks if object follows the structure as found in ./jasmine/books.json]\n     * @param  {[object]} jsonFile [json file to be tested]\n     * @return {[boolean]}          [true if valid and false if invalid]\n     */\n  checkFileStructure(jsonFile) {\n    this.isValidFile = true;\n\n    jsonFile.forEach((document) => {\n      const isValidTitle = document.title !== undefined && document.title.length > 0 && typeof document.title === 'string';\n      const isValidText = document.text !== undefined && document.text.length > 0 && typeof document.text === 'string';\n      if (!(isValidText && isValidTitle)) {\n        this.isValidFile = false;\n        return false;\n      }\n    });\n    return this.isValidFile;\n  }\n\n    /**\n   * [cleanString This method takes in a string with whitespaces, non-alphanumric characters and\n   * Returns a clean version with all unecessary characters striped away]\n   * @param  {[string]} theString [the string to cleanup]\n   * @param  {[Regex]} theRegex  [the regex to use]\n   * @return {[String]}           [A string Strpped based on the regex]\n   */\n  cleanString(theString, theRegex) {\n    return theString.replace(theRegex, '').toLowerCase() || theString.replace(/[^a-z0-9\\s]+/gi, '').toLowerCase();\n  }\n}\nmodule.exports = util;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}